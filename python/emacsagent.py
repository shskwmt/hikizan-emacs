import os
import subprocess
import tempfile
import time
import re
import fnmatch

from typing import Annotated, Sequence, TypedDict
from pydantic import BaseModel, Field

from langchain_core.messages import BaseMessage, ToolMessage, SystemMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
from langchain_core.tools import tool
from langchain_community.tools import DuckDuckGoSearchResults
from langchain_community.utilities import DuckDuckGoSearchAPIWrapper
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.graph import END, StateGraph
from langgraph.graph.message import add_messages

# --- Constants ---

GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
MAIN_MODEL_NAME = "gemini-2.5-flash"
PRO_MODEL_NAME = "gemini-2.5-pro"
LLM_TEMPERATURE = 0

TIMEOUT = 60
SYSTEM_PROMPT = """
** Role
You are a large language model living in Emacs, a proactive and intelligent director for programming tasks. Your primary goal is to guide me, the user, to achieve our shared objectives efficiently and effectively. You are in charge.

** Context
- You are the director, and I am your assistant.
- You can execute Emacs Lisp code to interact with my Emacs environment.
- You have access to the local file system to read, write, list, find, and search files by executing Emacs Lisp code.

** Instructions
1.  **Analyze**: Understand the user's request and the current state.
2.  **Consult & Plan**: For any non-trivial task, your first step is to use the `consult_pro_agent` tool. Delegate the initial analysis and planning to this expert advisor to get a comprehensive, step-by-step plan. This is your primary strategy for ensuring success.
3.  **Approve**: Present the plan generated by the pro agent to me for approval.
4.  **Confirm**: You will confirm with me at each step of the approved plan before proceeding.
5.  **Direct**: Instruct me on what to do. You can ask me for information, clarification, or to perform actions.
6.  **Execute**: You will generate the necessary Emacs Lisp code for me to execute for each step.
7.  **Verify**: After each step, verify the outcome and adjust the plan as needed. If you encounter an error, consider consulting the `pro_agent` again for a solution.
8.  **Conclude**: Inform me when the task is complete and summarize the results.
9.  **Research**: When performing research, use `search_tool` first to find relevant information, and then use `browse_web_page` on promising URLs from the search results to gather detailed content.

** Paradigm
- **Proactive, not reactive**: Don't wait for my specific instructions. Take the initiative to move the project forward.
- **Inquisitive**: If you lack information, ask me for it. Assume I have the context you need, but you must elicit it.
- **Authoritative**: You are the expert. Guide me with confidence.

** Tool Reference
- `execute_elisp_code(code: str) -> str`: Executes Emacs Lisp code. Must print the result to be captured.
- `search_tool(query: str) -> str`: Performs a DuckDuckGo search and returns a summary of the results with links.
- `browse_web_page(url: str) -> str`: Browses the given URL and returns the clean text content of the page.
- `consult_pro_agent(query: str) -> str`: Consults a more powerful agent for complex reasoning or tasks.

** Instructions of the `execute_elisp_code`

- You must print the result if you want to get the result by using the `message` function.

example
```emacs-lisp
(message \"%s\" result)
```

*** ELISP Code Examples:

#+begin_src emacs-lisp
;; Retrieve a list of buffers
(with-current-buffer (list-buffers-noselect)
 (message "%s" (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

#+begin_src emacs-lisp
;; Read the contents of a specific buffer by name
(with-current-buffer "{buffer-name}" ;; Replace {buffer-name} with the actual buffer name
  (message "%s" (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

#+begin_src emacs-lisp
;; Create a new commit
(let ((commit-message "{commit-message}")) ;; Replace {commit-message} with the actual commit message
  (with-current-buffer "{buffer-name}" ;; Replace {buffer-name} with the actual buffer name
    (magit-run-git "commit" "-m" commit-message))
  (message "Commit successful."))
#+end_src
"""

PRO_AGENT_SYSTEM_PROMPT = """
** Role
You are a highly intelligent and experienced programming advisor. Your primary role is to provide strategic guidance, deeper analysis, and comprehensive solutions to the main Emacs Agent. You are not to execute tasks directly but to offer well-reasoned advice and plans that the main agent can follow.

** Context
- You are advising another AI agent (the main Emacs Agent) that has access to Emacs and other tools.
- Your advice should be actionable and clear, enabling the main agent to proceed effectively.

** Instructions
1.  **Analyze**: Understand the main agent's query and the current situation.
2.  **Advise**: Provide a detailed plan or a set of recommendations to the main agent.
3.  **Reason**: Explain your thought process and the rationale behind your advice.

** Paradigm
- **Strategic**: Think several steps ahead and consider the broader implications.
- **Analytical**: Break down complex problems and offer insightful solutions.
- **Supportive**: Your goal is to empower the main agent to succeed.

** Tool Reference
- `execute_elisp_code(code: str) -> str`: Executes Emacs Lisp code. Must print the result to be captured.
- `search_tool(query: str) -> str`: Performs a DuckDuckGo search and returns a summary of the results with links.
- `browse_web_page(url: str) -> str`: Browses the given URL and returns the clean text content of the page.

** Instructions of the `execute_elisp_code`

- You must print the result if you want to get the result by using the `message` function.

example
```emacs-lisp
(message \"%s\" result)```

*** ELISP Code Examples:

#+begin_src emacs-lisp
;; Retrieve a list of buffers
(with-current-buffer (list-buffers-noselect)
 (message \"%s\" (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

#+begin_src emacs-lisp
;; Read the contents of a specific buffer by name
(with-current-buffer \"{buffer-name}\" ;; Replace {buffer-name} with the actual buffer name
  (message \"%s\" (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

#+begin_src emacs-lisp
;; Create a new commit
(let ((commit-message "{commit-message}")) ;; Replace {commit-message} with the actual commit message
  (with-current-buffer "{buffer-name}" ;; Replace {buffer-name} with the actual buffer name
    (magit-run-git "commit" "-m" commit-message))
  (message "Commit successful."))
#+end_src
"""


# --- State Definition ---

class AgentState(TypedDict):
    """The state of the agent."""
    messages: Annotated[Sequence[BaseMessage], add_messages]


# --- Base Agent Logic ---

class BaseAgent:
    """Base class for agent logic, tool handling, and graph construction."""
    def __init__(self, model_name: str, tools: list):
        if not GOOGLE_API_KEY:
            raise ValueError("GOOGLE_API_KEY environment variable not set.")

        self.llm = ChatGoogleGenerativeAI(
            model=model_name,
            temperature=LLM_TEMPERATURE,
            timeout=TIMEOUT,
            google_api_key=GOOGLE_API_KEY,
        )
        self.tools = tools
        self.tools_by_name = {tool.name: tool for tool in self.tools}
        self.graph = self._build_graph()
        self.system_prompt = SYSTEM_PROMPT

    def _build_graph(self) -> StateGraph:
        """Builds and compiles the LangGraph execution graph."""
        workflow = StateGraph(AgentState)
        workflow.add_node("llm", self.call_model)
        workflow.add_node("tools", self.call_tool)
        workflow.set_entry_point("llm")
        workflow.add_conditional_edges(
            "llm",
            self.should_continue,
            {"continue": "tools", "end": END},
        )
        workflow.add_edge("tools", "llm")
        return workflow.compile()

    def should_continue(self, state: AgentState) -> str:
        """Determines whether the agent should continue or end."""
        last_msg = state["messages"][-1]
        if hasattr(last_msg, "tool_calls") and last_msg.tool_calls:
            return "continue"
        return "end"

    def call_model(self, state: AgentState, config: RunnableConfig):
        """Invokes the LLM with the current state and tools."""
        model_with_tools = self.llm.bind_tools(self.tools)
        response = model_with_tools.invoke(state["messages"], config)
        return {"messages": [response]}

    def call_tool(self, state: AgentState):
        """Calls the appropriate tool based on the LLM's request."""
        outputs = []
        last_message = state["messages"][-1]

        if hasattr(last_message, "tool_calls") and last_message.tool_calls:
            for tool_call in last_message.tool_calls:
                tool_result = self.tools_by_name[tool_call["name"]].invoke(tool_call["args"])
                if not tool_result:
                    tool_result = "Tool returned no output."
                outputs.append(
                    ToolMessage(
                        content=str(tool_result),
                        name=tool_call["name"],
                        tool_call_id=tool_call["id"],
                    )
                )
        return {"messages": outputs}


# --- Tools ---

search_wrapper = DuckDuckGoSearchAPIWrapper(max_results=30)
search_tool = DuckDuckGoSearchResults(api_wrapper=search_wrapper, source="text")

def write_elisp_code_to_temp_file(code: str) -> str:
    """Create a temp file and write the provided code into it."""
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.el') as temp_file:
        temp_file.write(code)
        return temp_file.name.replace("\\", "/")

class ElispCode(BaseModel):
    code: str = Field(description="The Emacs Lisp code to execute. It must print its result to be captured.")

def _execute_elisp_code(code: str) -> str:
    temp_file_path = write_elisp_code_to_temp_file(code)
    # print(f"Emacs LISP code written to: {temp_file_path}")
    command = f"emacsclientw.exe -e \"(hikizan/eval-elisp-file \\\"{temp_file_path}\\\")\""
    try:
        subprocess.run(command, shell=True, check=True, text=True, capture_output=True)
        time.sleep(1)
        temp_log_file_path = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.log').name.replace("\\", "/")
        log_command = f"emacsclientw.exe -e \"(hikizan/write-string-to-file \\\"{temp_log_file_path}\\\" (hikizan/get-string-from-point (get-buffer \\\"*Messages*\\\") (hikizan/find-string-position-in-buffer (get-buffer \\\"*Messages*\\\") \\\"{temp_file_path}\\\")))\""
        subprocess.run(log_command, shell=True, check=True, text=True, capture_output=True)
        # print(f"Log written to: {temp_log_file_path}")
        with open(temp_log_file_path, 'r', encoding='utf-8') as log_file:
            return log_file.read().strip()
    except Exception as e:
        return f"Error: {str(e)}"

@tool(args_schema=ElispCode)
def execute_elisp_code(code: str) -> str:
    """Executes Emacs Lisp code and returns the result or an error message."""
    return _execute_elisp_code(code)

class WebPageURL(BaseModel):
    url: str = Field(description="The URL to browse.")

@tool(args_schema=WebPageURL)
def browse_web_page(url: str) -> str:
    """Browses a web page and returns its clean text content."""
    return _execute_elisp_code(f"(message \"%s\" (browse-page-get-clean-text \"{url}\" 3))")


# --- Pro Agent for Consultation ---

class ProAgent(BaseAgent):
    """A specialized agent using the 'pro' model for complex tasks."""
    def __init__(self):
        # Note: Does not include the 'consult_pro_agent' tool to prevent recursion.
        pro_tools = [execute_elisp_code, search_tool, browse_web_page]
        super().__init__(model_name=PRO_MODEL_NAME, tools=pro_tools)
        self.system_prompt = PRO_AGENT_SYSTEM_PROMPT

    def run(self, query: str) -> str:
        """Runs the agent for a single query and returns the final string response."""
        print(f"\n\033[1;35mConsulting Pro Agent for query: {query}\033[0m")
        initial_state = {"messages": [SystemMessage(content=self.system_prompt), HumanMessage(content=query)]}
        final_state = self.graph.invoke(initial_state)
        final_message = final_state["messages"][-1]

        content = final_message.content
        if isinstance(content, list):
            content = "".join(str(part) for part in content if part)
        if not isinstance(content, str):
            content = str(content)

        print(f"\n\033[1;35mPro Agent finished with response: {content}\033[0m")
        return content

class ProAgentQuery(BaseModel):
    query: str = Field(description="The query or task to delegate to the more powerful Pro model agent.")

@tool(args_schema=ProAgentQuery)
def consult_pro_agent(query: str) -> str:
    """
    Consults a more powerful agent (using gemini-2.5-pro) for complex reasoning or tasks.
    Use this when a task is too complex for the current model, requires deeper analysis, or involves multiple steps that need to be orchestrated.
    Returns the final response from the pro agent.
    """
    pro_agent = ProAgent()
    result = pro_agent.run(query)
    return result


# --- Main Emacs Agent ---

def _format_and_print_message(message: BaseMessage):
    """Formats and prints a message based on its type and role."""
    if hasattr(message, "tool_calls") and message.tool_calls:
        function_name = message.tool_calls[0]["name"]
        function_args = message.tool_calls[0]["args"]
        print(f"\n\033[1;33mCalling tool: {function_name} with args: {function_args}\033[0m")
    elif isinstance(message, ToolMessage):
        truncated_content = (message.content[:300] + "...") if len(message.content) > 300 else message.content
        print(f"\n\033[1;32mTool Result:\n{truncated_content}\033[0m")
    else:
        content = message.content
        if isinstance(content, list):
            content = "".join(str(part) for part in content if part)
        if not isinstance(content, str):
            content = str(content)
        print(f"\n\033[1;36mAssistant:\n{content}\033[0m")

class EmacsAgent(BaseAgent):
    """The main, interactive agent using the 'flash' model."""
    def __init__(self):
        main_tools = [execute_elisp_code, search_tool, browse_web_page, consult_pro_agent]
        super().__init__(model_name=MAIN_MODEL_NAME, tools=main_tools)
        self.conversation_history = [SystemMessage(content=self.system_prompt)]

    def run(self, query: str):
        """Runs the agent interactively from a user query."""
        self.conversation_history.append(HumanMessage(content=query))
        initial_state = {"messages": self.conversation_history.copy()}
        initial_history_length = len(self.conversation_history)
        final_messages = []

        for event in self.graph.stream(initial_state, stream_mode="values"):
            latest_message = event["messages"][-1]
            final_messages = event["messages"]
            if not isinstance(latest_message, HumanMessage):
                _format_and_print_message(latest_message)

        if len(final_messages) > initial_history_length:
            new_messages = final_messages[initial_history_length:]
            self.conversation_history.extend(new_messages)

    def clear_history(self):
        """Clears the conversation history."""
        self.conversation_history = [SystemMessage(content=self.system_prompt)]
        print("Cleared conversation histories")

    def show_history(self):
        """Displays the conversation history."""
        print("\n=== Conversation Histories ===")
        for i, msg in enumerate(self.conversation_history):
            role = getattr(msg, "role", msg.__class__.__name__)
            print(f"{i+1}. [{role}]: {msg.content[:100]}{'...' if len(msg.content) > 100 else ''}")
        print("==============================\n")


def main():
    """Main function to run the Emacs Agent."""
    print("Welcome to the Emacs Agent!")
    print("You can ask me to perform tasks in Emacs.")
    print("Special commands:")
    print("  - 'exit' or 'quit': end the session")
    print("  - 'clear': clear conversation history")
    print("  - 'history': show conversation history")

    try:
        agent = EmacsAgent()
        while True:
            query = input("\n> ")
            if query.lower() in ["exit", "quit"]:
                break
            elif query.lower() == "clear":
                agent.clear_history()
                continue
            elif query.lower() == "history":
                agent.show_history()
                continue
            agent.run(query)
    except ValueError as e:
        print(f"\n\033[1;31mInitialization Error: {e}\033[0m")
    except Exception as e:
        print(f"\n\033[1;31mAn unexpected error occurred: {e}\033[0m")

if __name__ == "__main__":
    # To run this script:
    # 1. Make sure you have an Emacs server running (`M-x server-start` in Emacs).
    # 2. Set your Google API key: `export GOOGLE_API_KEY='your_key_here'`
    # 3. Run the script: `python emacsagent.py`
    #
    # Example Query: "List all open buffers in Emacs."
    main()
